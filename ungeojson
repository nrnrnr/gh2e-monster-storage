#!/usr/bin/env lua5.1
-- poly2.lua â€” read polygon JSON (GeoJSON-ish) and emit TikZ or OpenSCAD
-- deps: dkjson, your 'flags' library

------------------ classic print functions ---------------------
local stringf = string.format
local function printf(...) return io.stdout:write(stringf(...)) end
local function eprintf(...) return io.stderr:write(stringf(...)) end
local function fprintf(fd, ...) return fd:write(stringf(...)) end
local function dief(...) eprintf(...); os.exit(1) end
local function errorf(...) return error(stringf(...)) end
local function runf(...) return os.execute(stringf(...)) end
----------------------------------------------------------------
local json = require "dkjson"

-- ----- flags: use your template -----
local fields = require('flags').parser()
  :enum('what', {'tikz', 'openscad as scad'}, 'tikz')
  :help('tikz', 'write tikz')
  :help('openscad', 'write openscad')
  :numarg(1)
  :parse(arg)

-- ----- helpers -----
local function read_json(path)
  local f, err = io.open(path, "rb")
  if not f then error(err) end
  local txt = f:read("*a"); f:close()
  local obj, pos, jerr = json.decode(txt, 1, nil)
  if not obj then error("JSON decode error at "..tostring(pos)..": "..tostring(jerr)) end
  return obj
end

local function isnum(x) return type(x) == "number" end

local function pt_eq(a, b, eps)
  eps = eps or 1e-9
  return math.abs(a[1]-b[1]) < eps and math.abs(a[2]-b[2]) < eps
end

local function normalize_ring(ring)
  -- copy valid 2D points; drop duplicate closing vertex
  local out = {}
  for i=1,#ring do
    local p = ring[i]
    if type(p) == "table" and isnum(p[1]) and isnum(p[2]) then
      out[#out+1] = { p[1], p[2] }
    end
  end
  if #out >= 2 and pt_eq(out[1], out[#out]) then table.remove(out, #out) end
  return out
end

-- Extract polygons as: { { ring1, ring2(hole), ... }, ... }
local function extract_polys(obj)
  local polys = {}

  local function push_polygon_from_coords(coords)
    -- coords for Polygon: [ ring, ring, ... ]
    local rings = {}
    for _,ring in ipairs(coords or {}) do
      rings[#rings+1] = normalize_ring(ring)
    end
    polys[#polys+1] = rings
  end

  if not obj then error("No JSON object") end
  local t = obj.type

  if t == "FeatureCollection" and obj.features then
    for _,feat in ipairs(obj.features) do
      if feat and feat.geometry then
        local g = feat.geometry
        if g.type == "Polygon" then
          push_polygon_from_coords(g.coordinates)
        elseif g.type == "MultiPolygon" then
          for _,poly in ipairs(g.coordinates or {}) do
            push_polygon_from_coords(poly)
          end
        end
      end
    end
  elseif t == "Feature" and obj.geometry then
    return extract_polys(obj.geometry)
  elseif t == "Polygon" then
    push_polygon_from_coords(obj.coordinates)
  elseif t == "MultiPolygon" then
    for _,poly in ipairs(obj.coordinates or {}) do
      push_polygon_from_coords(poly)
    end
  else
    error("Unsupported or missing GeoJSON type: "..tostring(t))
  end

  if #polys == 0 then error("No polygons found in JSON") end
  return polys
end

local numbers = { 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine' }
numbers[0] = 'zero'

for i = 0, 9 do
  numbers[tostring(i)] = numbers[i]
end

local function println(...)
  printf(...)
  io.stdout:write '\n'
end

-- Calculate centroid of a polygon using the standard formula
local function polygon_centroid(ring)
  if #ring < 3 then return 0, 0 end -- degenerate polygon
  
  local area = 0
  local cx, cy = 0, 0
  
  for i = 1, #ring do
    local j = (i % #ring) + 1
    local x1, y1 = ring[i][1], ring[i][2]  
    local x2, y2 = ring[j][1], ring[j][2]
    
    local cross = x1 * y2 - x2 * y1
    area = area + cross
    cx = cx + (x1 + x2) * cross
    cy = cy + (y1 + y2) * cross
  end
  
  area = area / 2
  if math.abs(area) < 1e-10 then return 0, 0 end -- avoid division by zero
  
  cx = cx / (6 * area)
  cy = cy / (6 * area)
  
  return cx, cy
end

-- Calculate centroid of multiple polygons (weighted by area)
local function polys_centroid(polys, transform_pt)
  local total_area = 0
  local weighted_cx, weighted_cy = 0, 0
  
  for _,rings in ipairs(polys) do
    for _,ring in ipairs(rings) do
      if #ring >= 3 then
        -- Transform the ring points first
        local transformed_ring = {}
        for _,pt in ipairs(ring) do
          local x, y = transform_pt(pt[1], pt[2])
          transformed_ring[#transformed_ring+1] = {x, y}
        end
        
        local cx, cy = polygon_centroid(transformed_ring)
        
        -- Calculate area for weighting
        local area = 0
        for i = 1, #transformed_ring do
          local j = (i % #transformed_ring) + 1
          local x1, y1 = transformed_ring[i][1], transformed_ring[i][2]
          local x2, y2 = transformed_ring[j][1], transformed_ring[j][2]
          area = area + (x1 * y2 - x2 * y1)
        end
        area = math.abs(area) / 2
        
        weighted_cx = weighted_cx + cx * area
        weighted_cy = weighted_cy + cy * area
        total_area = total_area + area
      end
    end
  end
  
  if total_area < 1e-10 then return 0, 0 end
  
  return weighted_cx / total_area, weighted_cy / total_area
end

-- ----- emitters -----
local function emit_tikz(polys, filename, dpi)
  -- emits a single \path with subpaths; caller can add even-odd fill rule when using it
  local inches_per_dot = 1.0 / dpi
  local mm_per_inch = 25.4
  local function mm(dots) return mm_per_inch * inches_per_dot * dots end
  
  -- Helper function to build path pieces from polygons
  local function build_pieces(polys, transform_pt)
    local pieces = {}
    for _,rings in ipairs(polys) do
      for _,ring in ipairs(rings) do
        if #ring >= 2 then
          local seg = {}
          for i,pt in ipairs(ring) do
            local x, y = transform_pt(pt[1], pt[2])
            seg[#seg+1] = string.format("+(%g,%g)", mm(x), mm(y))
            if i < #ring then seg[#seg+1] = " -- " end
          end
          seg[#seg+1] = " -- cycle"
          pieces[#pieces+1] = table.concat(seg, '\n    ')
        end
      end
    end
    return pieces
  end
  
  -- Helper function to find bounding box of transformed points
  local function find_bbox(polys, transform_pt)
    local min_x, min_y, max_x, max_y = math.huge, math.huge, -math.huge, -math.huge
    for _,rings in ipairs(polys) do
      for _,ring in ipairs(rings) do
        for _,pt in ipairs(ring) do
          local x, y = transform_pt(pt[1], pt[2])
          min_x, max_x = math.min(min_x, x), math.max(max_x, x)
          min_y, max_y = math.min(min_y, y), math.max(max_y, y)
        end
      end
    end
    return min_x, min_y, max_x, max_y
  end
  
  -- Helper function to output width and height for a path variant
  local function output_dimensions(macro, suffix, min_x, min_y, max_x, max_y)
    local width = mm(max_x - min_x)
    local height = mm(max_y - min_y)
    println([[\setwidth{%s%s}{%g}]], macro, suffix, width)
    println([[\setheight{%s%s}{%g}]], macro, suffix, height)
  end
  
  -- Original path (no transformation)
  local min_x_orig, min_y_orig, max_x_orig, max_y_orig = find_bbox(polys, function(x, y) return x, y end)
  local pieces = build_pieces(polys, function(x, y) return x, y end)
  
  -- Rotated path (90 degrees with bounding box adjustment)
  local min_x_90, min_y_90, max_x_90, max_y_90 = find_bbox(polys, function(x, y) return -y, x end)
  local pieces_90 = build_pieces(polys, function(x, y) 
    return -y - min_x_90, x - min_y_90
  end)
  
  -- Rotated path (-90 degrees with bounding box adjustment)
  local min_x_neg90, min_y_neg90, max_x_neg90, max_y_neg90 = find_bbox(polys, function(x, y) return y, -x end)
  local pieces_neg90 = build_pieces(polys, function(x, y) 
    return y - min_x_neg90, -x - min_y_neg90
  end)
  
  -- Rotated path (180 degrees with bounding box adjustment)
  local min_x_180, min_y_180, max_x_180, max_y_180 = find_bbox(polys, function(x, y) return -x, -y end)
  local pieces_180 = build_pieces(polys, function(x, y) 
    return -x - min_x_180, -y - min_y_180
  end)
  
  local macro = filename:gsub('^.*/', ''):gsub('region', ''):gsub('%.json$', '')
  println([[\setdpi{%s}{%g}]], macro, dpi)
  println([[\setunit{%s}{%g}]], macro, 1.0 / dpi)
  
  -- Output dimensions for original only
  output_dimensions(macro, "", min_x_orig, min_y_orig, max_x_orig, max_y_orig)
  
  -- Calculate centroids for each orientation
  local cx_orig, cy_orig = polys_centroid(polys, function(x, y) return x, y end)
  local cx_90, cy_90 = polys_centroid(polys, function(x, y) return -y - min_x_90, x - min_y_90 end)
  local cx_neg90, cy_neg90 = polys_centroid(polys, function(x, y) return y - min_x_neg90, -x - min_y_neg90 end)
  local cx_180, cy_180 = polys_centroid(polys, function(x, y) return -x - min_x_180, -y - min_y_180 end)
  
  -- Output path definitions
  println([[\defpath{%s}{%s}]], macro, table.concat(pieces, " "))
  println([[\defpath{%s angle=90}{%s}]], macro, table.concat(pieces_90, " "))
  println([[\defpath{%s angle=-90}{%s}]], macro, table.concat(pieces_neg90, " "))
  println([[\defpath{%s angle=180}{%s}]], macro, table.concat(pieces_180, " "))
  
  -- Output centroid definitions
  println([[\defcentroid{%s}{(%g,%g)}]], macro, mm(cx_orig), mm(cy_orig))
  println([[\defcentroid{%s angle=90}{(%g,%g)}]], macro, mm(cx_90), mm(cy_90))
  println([[\defcentroid{%s angle=-90}{(%g,%g)}]], macro, mm(cx_neg90), mm(cy_neg90))  
  println([[\defcentroid{%s angle=180}{(%g,%g)}]], macro, mm(cx_180), mm(cy_180))
end

local function emit_openscad(polys, filename, dpi)
  -- OpenSCAD functions for different rotations with millimeter coordinates
  local inches_per_dot = 1.0 / dpi
  local mm_per_inch = 25.4
  local function mm(dots) return mm_per_inch * inches_per_dot * dots end

  -- Helper function to format points array for a given transformation
  local function fmt_points_transformed(polys, transform_pt, translate_pt)
    local points = {}
    for _,rings in ipairs(polys) do
      for _,ring in ipairs(rings) do
        for _,pt in ipairs(ring) do
          local x, y = transform_pt(pt[1], pt[2])
          if translate_pt then
            x, y = translate_pt(x, y)
          end
          points[#points+1] = string.format("[%g,%g]", mm(x), mm(y))
        end
      end
    end
    return "["..table.concat(points, ", ").."]"
  end

  -- Helper function to find bounding box for translation
  local function find_bbox_for_transform(polys, transform_pt)
    local min_x, min_y = math.huge, math.huge
    for _,rings in ipairs(polys) do
      for _,ring in ipairs(rings) do
        for _,pt in ipairs(ring) do
          local x, y = transform_pt(pt[1], pt[2])
          min_x, min_y = math.min(min_x, x), math.min(min_y, y)
        end
      end
    end
    return min_x, min_y
  end

  -- Calculate points for each rotation
  local points_0 = fmt_points_transformed(polys, function(x, y) return x, y end)
  
  local min_x_90, min_y_90 = find_bbox_for_transform(polys, function(x, y) return -y, x end)
  local points_90 = fmt_points_transformed(polys, function(x, y) return -y, x end, function(x, y) return x - min_x_90, y - min_y_90 end)
  
  local min_x_neg90, min_y_neg90 = find_bbox_for_transform(polys, function(x, y) return y, -x end)
  local points_neg90 = fmt_points_transformed(polys, function(x, y) return y, -x end, function(x, y) return x - min_x_neg90, y - min_y_neg90 end)
  
  local min_x_180, min_y_180 = find_bbox_for_transform(polys, function(x, y) return -x, -y end)
  local points_180 = fmt_points_transformed(polys, function(x, y) return -x, -y end, function(x, y) return x - min_x_180, y - min_y_180 end)

  -- Calculate original bounding box for metrics
  local min_x_orig, min_y_orig = math.huge, math.huge
  local max_x_orig, max_y_orig = -math.huge, -math.huge
  for _,rings in ipairs(polys) do
    for _,ring in ipairs(rings) do
      for _,pt in ipairs(ring) do
        local x, y = pt[1], pt[2]
        min_x_orig, max_x_orig = math.min(min_x_orig, x), math.max(max_x_orig, x)
        min_y_orig, max_y_orig = math.min(min_y_orig, y), math.max(max_y_orig, y)
      end
    end
  end

  local macro = filename:gsub('^.*/', ''):gsub('region', ''):gsub('%.json$', '')
  local width = mm(max_x_orig - min_x_orig)
  local height = mm(max_y_orig - min_y_orig)

  -- Generate OpenSCAD output
  println('%s_metrics = [%g, %g];', macro, width, height)
  println('')
  println('function %s_path(angle=0) = ', macro)
  println('  angle == 0 || angle == 360 ? %s :', points_0)
  println('  angle == 90 || angle == -270 ? %s :', points_90)
  println('  angle == -90 || angle == 270 ? %s :', points_neg90)
  println('  angle == 180 || angle == -180 ? %s :', points_180)
  println('  assert(false, str("Invalid angle for %s_path: ", angle));', macro)
end

-- ----- HOF-style dispatch table -----
local how = {}

require 'ioutil'

function how.tikz(filename)
  local obj   = read_json(filename)
  local polys = extract_polys(obj)
  local letter = filename:gsub('%U', '')
  local dpi = assert(tonumber(assert(io.contents(stringf('build/dpi%s.float', letter)))))
  emit_tikz(polys, filename, dpi)
end

function how.openscad(filename)
  local obj   = read_json(filename)
  local polys = extract_polys(obj)
  local letter = filename:gsub('%U', '')
  local dpi = assert(tonumber(assert(io.contents(stringf('build/dpi%s.float', letter)))))
  emit_openscad(polys, filename, dpi)
end

-- ----- run -----
assert(how[fields.what], "unknown format: "..tostring(fields.what))(arg[1])
